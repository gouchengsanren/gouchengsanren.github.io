<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo的迁移</title>
    <url>/2020/04/06/hexo%E7%9A%84%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<p>由于hexo deploy的是编译生成的网页静态文件（hexo init下的.git_deploy）。<br>当更换电脑，由于没有源文件，我们没法更新博文。<br>所以有必要同时对hexo源文件进行备份（其他电脑可随时获取），并能快速恢复hexo环境。<br>本文参考大多数人的做法，将hexo源文件备份至github。</p>
<a id="more"></a>

<h2 id="在github-io仓中新建hexo分支管理源码"><a href="#在github-io仓中新建hexo分支管理源码" class="headerlink" title="在github.io仓中新建hexo分支管理源码"></a>在github.io仓中新建hexo分支管理源码</h2><hr>
<p>为了便于管理、维护（hexo d和git push源码在一个目录下操作），我们复用github.io仓<br>，新建一个分支 <code>hexo</code> 用于源码的管理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gouchengsanren.github.io - master（静态网页文件）</span><br><span class="line">                         \</span><br><span class="line">                           hexo（hexo源码）</span><br></pre></td></tr></table></figure>

<h3 id="创建hexo分支"><a href="#创建hexo分支" class="headerlink" title="创建hexo分支"></a>创建hexo分支</h3><img src="https://github.com/gouchengsanren/images/blob/master/blog/hexo%E7%9A%84%E8%BF%81%E7%A7%BB-%E5%88%9B%E5%BB%BAhexo%E5%88%86%E6%94%AF.png?raw=true" class="">


<h3 id="添加hexo源文件"><a href="#添加hexo源文件" class="headerlink" title="添加hexo源文件"></a>添加hexo源文件</h3><p>拉下github.io的代码：<br><code>git clone git@github.com:gouchengsanren/gouchengsanren.github.io.git</code></p>
<p>删除 <code>.git</code> 以外的其他文件：<br><code>rm -rf !(.git)</code></p>
<p>拷贝hexo源文件到本目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -rf &lt;hexo源文件根目录&gt;&#x2F;* .</span><br><span class="line">cp &lt;hexo源文件根目录&gt;&#x2F;.gitignore .</span><br></pre></td></tr></table></figure>

<p>删除其他的 <code>.git</code> 目录（因为git不允许仓库嵌套）：<br><code>find . -name .git</code><br>通常theme下的主题是git clone下来的，需要删除。</p>
<p>添加并上传：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;[ADD] 添加hexo源文件&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<br>

<h2 id="本地快速恢复hexo环境"><a href="#本地快速恢复hexo环境" class="headerlink" title="本地快速恢复hexo环境"></a>本地快速恢复hexo环境</h2><hr>
<p>在新环境下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:gouchengsanren&#x2F;gouchengsanren.github.io.git</span><br><span class="line">cd gouchengsanren.github.io</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>至此，环境就恢复了。<br><br></p>
<h2 id="需要提交的内容"><a href="#需要提交的内容" class="headerlink" title="需要提交的内容"></a>需要提交的内容</h2><hr>
<p>除了 <code>hexo d</code> 提交网页静态文件到 <code>master</code> 分支。<br>还需要 <code>git add</code> 和 <code>git push</code> 源文件到 <code>hexo</code> 分支。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>gcc</title>
    <url>/2020/04/12/gcc/</url>
    <content><![CDATA[<p>gcc的一些基础知识。<br>编译到底做了一些什么，编译时的注意事项等等。</p>
<a id="more"></a>

<h2 id="头文件的位置"><a href="#头文件的位置" class="headerlink" title="头文件的位置"></a>头文件的位置</h2><p>像 <code>stdio.h</code> 在编译器中的 <code>include</code> 目录。<br>自己需要的头文件，编译时用 <code>-I</code> 指定，比如 <code>-I ./</code><br><br></p>
<h2 id="库的位置"><a href="#库的位置" class="headerlink" title="库的位置"></a>库的位置</h2><p>像 <code>printf</code> 函数，都在事先编好的库中。库在编译器中的 <code>lib</code> 目录。<br>编译时，</p>
<ul>
<li>用 <code>-lxxx</code> 指定需要的库，编译器会去 <code>lib</code> 、 <code>usr/lib</code> 目录下找叫 <code>libxxx.so</code><br><code>libxxx.so.数字</code> <code>libxxx.a</code> 的库文件。</li>
<li>用 <code>-L xxx</code> 指定库的路径。<br>
<br>

</li>
</ul>
<h2 id="GCC的编译过程"><a href="#GCC的编译过程" class="headerlink" title="GCC的编译过程"></a>GCC的编译过程</h2><p>韦老师团队写的下面这篇文档非常好。<br><a href="https://github.com/100askTeam/01_all_series_quickstart/blob/master/04_%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8_%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%A7%8B/01_%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/doc_pic/01.%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.docx" target="_blank" rel="noopener">01.嵌入式Linux应用开发基础知识.docx</a></p>
<p>最初的程序是程序员对着巨大的机器插拔线缆。<br>之后有了纸带打孔编程，指代上的洞代表01，一条纸带就是要给程序。<br>再之后，就用一段特定的代码来表示一段特定的01串。这就是汇编语言。<br>再往后，就出现了c等高级语言。</p>
<p>对老师的文档做下摘要和总结。</p>
<p>一个c/cpp文件的编译分为4步：</p>
<ul>
<li>1）预处理，preprocessing。</li>
<li>2）编译，compilation。</li>
<li>3）汇编，assembly。</li>
<li>4）链接，linking。</li>
</ul>
<br>

<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>在c/cpp中，以 <code>#</code> 开头的都叫做 <code>预处理命令</code> ，包括 <code>#include</code> <code>#define</code> <code>#if</code> 等。<br>预处理要做的就是将它们展开或选择需要编译的代码。</p>
<p>例：<br><code>gcc -E -o main.i main.c -I ./</code><br>预处理不加 <code>-o</code> 选项时，会以标准输出的形式打出来。<br>预处理，需要 <code>-I</code> 。一但 <code>.i</code> 文件生成了，后续的编译就不需要再指定 <code>-I</code> 了。<br><br></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>代码决定后，正式将这些c/cpp代码转换成汇编代码。<br>用到的工具为 <code>cc1</code> 。</p>
<p>例：<br><code>gcc -S main.i</code> 或者 <code>gcc -S -o main.s main.i</code><br>指不指定输出都可以。不指定，默认就是*.s。<br><br></p>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编就是将汇编代码转换成机器码。<br>用到的工具为 <code>as</code> 。</p>
<p>例：<br><code>gcc -c main.s</code> 或者 <code>gcc -c -o main.o main.s</code><br>指不指定输出都可以。不指定，默认就是*.o。<br><br></p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接就是将多个 <code>.o文件</code> <code>.so文件</code> 链接起来，生成app。<br>用到的工具为 <code>ld</code> 或者 <code>collect2</code> 。</p>
<p>例：<br><code>gcc -o main main.o sub.o</code><br>这里就必须指定了，否则默认生成的是 <code>a.out</code> 。<br><br></p>
<h3 id="gcc-v"><a href="#gcc-v" class="headerlink" title="gcc -v"></a>gcc -v</h3><p>可以通过 <code>-v</code> 看到上述过程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chuck@chuck11:~/bsp$ gcc -o main main.c sub.c -I ./ -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper</span><br><span class="line">OFFLOAD_TARGET_NAMES=nvptx-none</span><br><span class="line">OFFLOAD_TARGET_DEFAULT=1</span><br><span class="line">Target: x86_64-linux-gnu</span><br><span class="line">Configured with: ../src/configure -v --with-pkgversion='Ubuntu 7.5.0-3ubuntu1~18.04' --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04) </span><br><span class="line">COLLECT_GCC_OPTIONS='-o' 'main' '-I' './' '-v' '-mtune=generic' '-march=x86-64'</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/7/cc1 -quiet -v -I ./ -imultiarch x86_64-linux-gnu main.c -quiet -dumpbase main.c -mtune=generic -march=x86-64 -auxbase main -version -fstack-protector-strong -Wformat -Wformat-security -o /tmp/ccZkhzNQ.s</span><br><span class="line">GNU C11 (Ubuntu 7.5.0-3ubuntu1~18.04) version 7.5.0 (x86_64-linux-gnu)</span><br><span class="line">    compiled by GNU C version 7.5.0, GMP version 6.1.2, MPFR version 4.0.1, MPC version 1.1.0, isl version isl-0.19-GMP</span><br><span class="line"></span><br><span class="line">GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072</span><br><span class="line">ignoring nonexistent directory "/usr/local/include/x86_64-linux-gnu"</span><br><span class="line">ignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/7/../../../../x86_64-linux-gnu/include"</span><br><span class="line"><span class="meta">#</span><span class="bash">include <span class="string">"..."</span> search starts here:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;...&gt; search starts here:</span></span><br><span class="line"> ./</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/7/include</span><br><span class="line"> /usr/local/include</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/7/include-fixed</span><br><span class="line"> /usr/include/x86_64-linux-gnu</span><br><span class="line"> /usr/include</span><br><span class="line">End of search list.</span><br><span class="line">GNU C11 (Ubuntu 7.5.0-3ubuntu1~18.04) version 7.5.0 (x86_64-linux-gnu)</span><br><span class="line">    compiled by GNU C version 7.5.0, GMP version 6.1.2, MPFR version 4.0.1, MPC version 1.1.0, isl version isl-0.19-GMP</span><br><span class="line"></span><br><span class="line">GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072</span><br><span class="line">Compiler executable checksum: b62ed4a2880cd4159476ea8293b72fa8</span><br><span class="line">COLLECT_GCC_OPTIONS='-o' 'main' '-I' './' '-v' '-mtune=generic' '-march=x86-64'</span><br><span class="line"> as -v -I ./ --64 -o /tmp/cc3Tp9Or.o /tmp/ccZkhzNQ.s</span><br><span class="line">GNU assembler version 2.30 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.30</span><br><span class="line">COLLECT_GCC_OPTIONS='-o' 'main' '-I' './' '-v' '-mtune=generic' '-march=x86-64'</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/7/cc1 -quiet -v -I ./ -imultiarch x86_64-linux-gnu sub.c -quiet -dumpbase sub.c -mtune=generic -march=x86-64 -auxbase sub -version -fstack-protector-strong -Wformat -Wformat-security -o /tmp/ccZkhzNQ.s</span><br><span class="line">GNU C11 (Ubuntu 7.5.0-3ubuntu1~18.04) version 7.5.0 (x86_64-linux-gnu)</span><br><span class="line">    compiled by GNU C version 7.5.0, GMP version 6.1.2, MPFR version 4.0.1, MPC version 1.1.0, isl version isl-0.19-GMP</span><br><span class="line"></span><br><span class="line">GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072</span><br><span class="line">ignoring nonexistent directory "/usr/local/include/x86_64-linux-gnu"</span><br><span class="line">ignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/7/../../../../x86_64-linux-gnu/include"</span><br><span class="line"><span class="meta">#</span><span class="bash">include <span class="string">"..."</span> search starts here:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;...&gt; search starts here:</span></span><br><span class="line"> ./</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/7/include</span><br><span class="line"> /usr/local/include</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/7/include-fixed</span><br><span class="line"> /usr/include/x86_64-linux-gnu</span><br><span class="line"> /usr/include</span><br><span class="line">End of search list.</span><br><span class="line">GNU C11 (Ubuntu 7.5.0-3ubuntu1~18.04) version 7.5.0 (x86_64-linux-gnu)</span><br><span class="line">    compiled by GNU C version 7.5.0, GMP version 6.1.2, MPFR version 4.0.1, MPC version 1.1.0, isl version isl-0.19-GMP</span><br><span class="line"></span><br><span class="line">GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072</span><br><span class="line">Compiler executable checksum: b62ed4a2880cd4159476ea8293b72fa8</span><br><span class="line">sub.c: In function ‘sub_fun’:</span><br><span class="line">sub.c:3:8: warning: implicit declaration of function ‘printf’ [-Wimplicit-function-declaration]</span><br><span class="line">        printf("Sub fun!\n");</span><br><span class="line">        ^~~~~~</span><br><span class="line">sub.c:3:8: warning: incompatible implicit declaration of built-in function ‘printf’</span><br><span class="line">sub.c:3:8: note: include ‘&lt;stdio.h&gt;’ or provide a declaration of ‘printf’</span><br><span class="line">COLLECT_GCC_OPTIONS='-o' 'main' '-I' './' '-v' '-mtune=generic' '-march=x86-64'</span><br><span class="line"> as -v -I ./ --64 -o /tmp/ccA3F0W2.o /tmp/ccZkhzNQ.s</span><br><span class="line">GNU assembler version 2.30 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.30</span><br><span class="line">COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/</span><br><span class="line">LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/7/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/7/../../../:/lib/:/usr/lib/</span><br><span class="line">COLLECT_GCC_OPTIONS='-o' 'main' '-I' './' '-v' '-mtune=generic' '-march=x86-64'</span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/7/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/7/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper -plugin-opt=-fresolution=/tmp/ccskUa6D.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro -o main /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/7 -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/7/../../.. /tmp/cc3Tp9Or.o /tmp/ccA3F0W2.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crtn.o</span><br><span class="line">COLLECT_GCC_OPTIONS='-o' 'main' '-I' './' '-v' '-mtune=generic' '-march=x86-64'</span><br></pre></td></tr></table></figure>

<p>可以清晰的看出编译的过程。<br>其中：<br><code>/usr/lib/gcc/x86_64-linux-gnu/7/cc1</code> 生成的 <code>.s</code> ， <code>as</code> 生成的 <code>.o</code> 都位于 <code>/tmp/</code> 目录下。<br>最终链接使用的是 <code>/usr/lib/gcc/x86_64-linux-gnu/7/collect2</code> 。<br><br></p>
<h3 id="gcc-Wall"><a href="#gcc-Wall" class="headerlink" title="gcc -Wall"></a>gcc -Wall</h3><p>打开告警。<br><br></p>
<h3 id="gcc-g"><a href="#gcc-g" class="headerlink" title="gcc -g"></a>gcc -g</h3><p>以操作系统的本地格式（stabs，COFF，XCOFF，或DWARF）产生调试信息，gdb能使用这些信息。<br>我们反汇编，也必须加上 <code>-g</code> ，否则没有函数信息，看不懂汇编的就会一脸懵逼。</p>
<p>加上 <code>-g</code> 后，文件明显的就变大了。<br>例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chuck@chuck11:~/bsp$ gcc -c main.c -I ./</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ ll</span><br><span class="line">total 28</span><br><span class="line">drwxrwxr-x  2 chuck chuck 4096 Apr 18 08:42 ./</span><br><span class="line">drwxr-xr-x 17 chuck chuck 4096 Apr 18 08:16 ../</span><br><span class="line">-rw-rw-r--  1 chuck chuck  153 Apr 12 12:52 main.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck 1608 Apr 18 08:42 main.o</span><br><span class="line">-rw-rw-r--  1 chuck chuck  139 Apr 12 12:51 Makefile</span><br><span class="line">-rw-rw-r--  1 chuck chuck   52 Apr 12 12:51 sub.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck   19 Apr 12 12:51 sub.h</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ gcc -c main.c -I ./ -g -o a.o</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ ll</span><br><span class="line">total 36</span><br><span class="line">drwxrwxr-x  2 chuck chuck 4096 Apr 18 08:43 ./</span><br><span class="line">drwxr-xr-x 17 chuck chuck 4096 Apr 18 08:16 ../</span><br><span class="line">-rw-rw-r--  1 chuck chuck 5992 Apr 18 08:43 a.o</span><br><span class="line">-rw-rw-r--  1 chuck chuck  153 Apr 12 12:52 main.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck 1608 Apr 18 08:42 main.o</span><br><span class="line">-rw-rw-r--  1 chuck chuck  139 Apr 12 12:51 Makefile</span><br><span class="line">-rw-rw-r--  1 chuck chuck   52 Apr 12 12:51 sub.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck   19 Apr 12 12:51 sub.h</span><br></pre></td></tr></table></figure>
<br>


<h3 id="gcc-O"><a href="#gcc-O" class="headerlink" title="gcc -O"></a>gcc -O</h3><p>优化选项。没有搞懂的欲望。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-O</td>
<td>不优化</td>
</tr>
<tr>
<td>-O2</td>
<td><strong>TODO</strong></td>
</tr>
<tr>
<td>-O3</td>
<td><strong>TODO</strong></td>
</tr>
</tbody></table>
<p>例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chuck@chuck11:~/bsp$ gcc -c main.c -I ./ -O2 -o main_o2.o</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ gcc -c main.c -I ./</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ gcc -c main.c -I ./ -O3 -o main_o3.o</span><br><span class="line">chuck@chuck11:~/bsp$ gcc -c main.c -I ./ -O1 -o main_o1.o</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ ll</span><br><span class="line">total 40</span><br><span class="line">drwxrwxr-x  2 chuck chuck 4096 Apr 18 08:50 ./</span><br><span class="line">drwxr-xr-x 17 chuck chuck 4096 Apr 18 08:16 ../</span><br><span class="line">-rw-rw-r--  1 chuck chuck  153 Apr 12 12:52 main.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck 1608 Apr 18 08:50 main.o</span><br><span class="line">-rw-rw-r--  1 chuck chuck 1624 Apr 18 08:50 main_o1.o</span><br><span class="line">-rw-rw-r--  1 chuck chuck 1728 Apr 18 08:50 main_o2.o</span><br><span class="line">-rw-rw-r--  1 chuck chuck 1728 Apr 18 08:50 main_o3.o</span><br><span class="line">-rw-rw-r--  1 chuck chuck  139 Apr 12 12:51 Makefile</span><br><span class="line">-rw-rw-r--  1 chuck chuck   52 Apr 12 12:51 sub.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck   19 Apr 12 12:51 sub.h</span><br></pre></td></tr></table></figure>
<p>随着优化等级变高，代码变多了。<br><br></p>
<h3 id="链接选项"><a href="#链接选项" class="headerlink" title="链接选项"></a>链接选项</h3><p>选项比较多，可以参考：<br><a href="https://github.com/100askTeam/01_all_series_quickstart/blob/master/04_%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8_%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%A7%8B/01_%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/doc_pic/01.%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.docx" target="_blank" rel="noopener">01.嵌入式Linux应用开发基础知识.docx</a></p>
<h4 id="动态库和静态库"><a href="#动态库和静态库" class="headerlink" title="动态库和静态库"></a>动态库和静态库</h4><p>我们先来讲讲库。<br>库分：</p>
<ul>
<li>静态库， <code>.a</code> 文件</li>
<li>动态库， <code>.so</code> 文件</li>
</ul>
<p><strong>动态库</strong><br>通过 <code>-shared</code> 选项生成 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chuck@chuck11:~/bsp$ gcc -shared sub.c -o libsub.so</span><br><span class="line">chuck@chuck11:~/bsp$ gcc -o main main.c -I ./ -lsub -L ./</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ ./main </span><br><span class="line">./main: error while loading shared libraries: libsub.so: cannot open shared object file: No such file or directory</span><br><span class="line">chuck@chuck11:~/bsp$ ll main</span><br><span class="line">-rwxrwxr-x 1 chuck chuck 8328 Apr 18 17:50 main*</span><br></pre></td></tr></table></figure>
<p>注意我故意列出了main的大小 <code>8328</code> 字节。<br><em><code>-shared</code> 不加 <code>-o</code> 默认生成的文件为 <code>a.out</code> ，所以一定要加 <code>-o</code> ，否则没法链接的。</em></p>
<p><strong>静态库</strong></p>
<blockquote>
<p>那么 <code>.a</code> 和 <code>.so</code> 是否仅仅是名字上的差别呢？</p>
</blockquote>
<p>我们来做个实验。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chuck@chuck11:~/bsp$ gcc -shared sub.c -o libsub.a</span><br><span class="line">chuck@chuck11:~/bsp$ ll</span><br><span class="line">total 40</span><br><span class="line">drwxrwxr-x  2 chuck chuck 4096 Apr 18 17:56 ./</span><br><span class="line">drwxr-xr-x 17 chuck chuck 4096 Apr 18 17:32 ../</span><br><span class="line">-rwxrwxr-x  1 chuck chuck 7896 Apr 18 17:56 libsub.a*</span><br><span class="line">-rwxrwxr-x  1 chuck chuck 7896 Apr 18 17:50 libsub.so*</span><br><span class="line">-rw-rw-r--  1 chuck chuck  153 Apr 12 12:52 main.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck  139 Apr 12 12:51 Makefile</span><br><span class="line">-rw-rw-r--  1 chuck chuck   52 Apr 12 12:51 sub.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck   19 Apr 12 12:51 sub.h</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ gcc -o main main.c -I ./ -lsub -L ./</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ ./main </span><br><span class="line">./main: error while loading shared libraries: libsub.so: cannot open shared object file: No such file or directory</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ rm libsub.so </span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ gcc -o main main.c -I ./ -lsub -L ./</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ ./main </span><br><span class="line">Main fun!</span><br><span class="line">Sub fun!</span><br><span class="line">chuck@chuck11:~/bsp$ ll main</span><br><span class="line">-rwxrwxr-x 1 chuck chuck 8328 Apr 18 17:56 main*</span><br><span class="line">chuck@chuck11:~/bsp$ diff libsub.a libsub.so</span><br><span class="line">chuck@chuck11:~/bsp$</span><br></pre></td></tr></table></figure>
<p>会发现：</p>
<ul>
<li>1）使用 <code>-shared</code> 生成 <code>.a</code> 和 <code>.so</code> 内容是一样的</li>
<li>2）链接，优先使用 <code>.so</code></li>
<li>3）链接后，使用 <code>.a</code> 链接的main是可以直接运行的！！！</li>
<li>4）<code>main</code> 的大小并没有差异，说明仍然是在运行时动态链接的</li>
</ul>
<p>我们继续实验：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chuck@chuck11:~/bsp$ cd ../</span><br><span class="line">chuck@chuck11:~$ </span><br><span class="line">chuck@chuck11:~$ cp bsp/main .</span><br><span class="line">chuck@chuck11:~$ </span><br><span class="line">chuck@chuck11:~$ ./main </span><br><span class="line">./main: error while loading shared libraries: .//libsub.a: cannot open shared object file: No such file or directory</span><br><span class="line">chuck@chuck11:~$ </span><br><span class="line">chuck@chuck11:~$ cp bsp/libsub.a .</span><br><span class="line">chuck@chuck11:~$ ./main </span><br><span class="line">Main fun!</span><br><span class="line">Sub fun!</span><br><span class="line">chuck@chuck11:~$</span><br></pre></td></tr></table></figure>
<p>也就是说，链接 <code>.a</code> 的app运行时要求库在当前目录，而链接 <code>.so</code> 的app运行时要求库在 <code>lib</code> 目录。</p>
<p>我们做下印证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chuck@chuck11:~$ su</span><br><span class="line">Password: </span><br><span class="line">root@chuck11:/home/chuck# </span><br><span class="line">root@chuck11:/home/chuck# cp bsp/libsub.a /usr/lib/</span><br><span class="line">root@chuck11:/home/chuck# ./main </span><br><span class="line">./main: error while loading shared libraries: .//libsub.a: cannot open shared object file: No such file or directory</span><br><span class="line">root@chuck11:/home/chuck# cp bsp/libsub.so /usr/lib/</span><br><span class="line">root@chuck11:/home/chuck# ./main </span><br><span class="line">./main: error while loading shared libraries: .//libsub.a: cannot open shared object file: No such file or directory</span><br><span class="line">root@chuck11:/home/chuck#</span><br><span class="line">root@chuck11:/home/chuck# cd bsp/</span><br><span class="line">root@chuck11:/home/chuck/bsp# gcc -o main main.c -I ./ -L ./ -lsub</span><br><span class="line">root@chuck11:/home/chuck/bsp# </span><br><span class="line">root@chuck11:/home/chuck/bsp# ./main </span><br><span class="line">Main fun!</span><br><span class="line">Sub fun!</span><br></pre></td></tr></table></figure>
<p>和预期一致。</p>
<blockquote>
<p>那么静态库正确的生成方法是？</p>
</blockquote>
<p>参考：<br><a href="http://c.biancheng.net/view/7168.html" target="_blank" rel="noopener">gcc生成静态链接库</a></p>
<p>我们使用 <code>ar</code> 命令。<br><code>ar rcs + 静态库文件的名字 + 目标文件列表</code><br>事实上，ar是linux的一个备份压缩命令，它将多个文件打包成一个备份文件（归档文件），<br>反过来也可以提取。</p>
<p>参数说明：</p>
<ul>
<li><code>r</code> 用来替换库中已有的目标文件，或者加入新的目标文件</li>
<li><code>c</code> 表示创建一个库。不管库否存在，都将创建</li>
<li><code>s</code> 用来创建目标文件索引，这在创建较大的库时能提高速度</li>
</ul>
<p>我们不需要记住每个参数的含义，记住使用 <code>ar rcs</code> 即可。<br>例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chuck@chuck11:~/bsp$ gcc -c -o sub.o sub.c</span><br><span class="line">chuck@chuck11:~/bsp$ ar rcs libsub.a sub.o </span><br><span class="line">chuck@chuck11:~/bsp$ gcc -o main main.c -I ./ -L ./ -lsub</span><br><span class="line">chuck@chuck11:~/bsp$ ll</span><br><span class="line">total 44</span><br><span class="line">drwxrwxr-x  2 chuck chuck 4096 Apr 18 18:38 ./</span><br><span class="line">drwxr-xr-x 17 chuck chuck 4096 Apr 18 18:34 ../</span><br><span class="line">-rw-rw-r--  1 chuck chuck 1680 Apr 18 18:38 libsub.a</span><br><span class="line">-rwxrwxr-x  1 chuck chuck 8360 Apr 18 18:38 main*</span><br><span class="line">-rw-rw-r--  1 chuck chuck  153 Apr 12 12:52 main.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck  139 Apr 12 12:51 Makefile</span><br><span class="line">-rw-rw-r--  1 chuck chuck   52 Apr 12 12:51 sub.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck   19 Apr 12 12:51 sub.h</span><br><span class="line">-rw-rw-r--  1 chuck chuck 1536 Apr 18 18:38 sub.o</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ ./main </span><br><span class="line">Main fun!</span><br><span class="line">Sub fun!</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ cd ../</span><br><span class="line">chuck@chuck11:~$ cp bsp/main .</span><br><span class="line">chuck@chuck11:~$ ./main </span><br><span class="line">Main fun!</span><br><span class="line">Sub fun!</span><br><span class="line">chuck@chuck11:~$</span><br></pre></td></tr></table></figure>
<p>不论哪个目录，<code>main</code> 都可以运行。而且大小相较动态库，变大了 <code>8360</code> 。<br>这才是静态库。</p>
<blockquote>
<p><em>注意：<code>ar</code> 打包的是归档文件，即 <code>.o</code> 文件，不能直接 <code>ar .c</code></em></p>
</blockquote>
<p>错误示范：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chuck@chuck11:~/bsp$ ar rcs -o libsub.a sub.c </span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ ll</span><br><span class="line">total 28</span><br><span class="line">drwxrwxr-x  2 chuck chuck 4096 Apr 18 18:43 ./</span><br><span class="line">drwxr-xr-x 17 chuck chuck 4096 Apr 18 18:42 ../</span><br><span class="line">-rw-rw-r--  1 chuck chuck  120 Apr 18 18:43 libsub.a</span><br><span class="line">-rw-rw-r--  1 chuck chuck  153 Apr 12 12:52 main.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck  139 Apr 12 12:51 Makefile</span><br><span class="line">-rw-rw-r--  1 chuck chuck   52 Apr 12 12:51 sub.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck   19 Apr 12 12:51 sub.h</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ gcc -o main main.c -I ./ -L ./ -lsub</span><br><span class="line">.//libsub.a: error adding symbols: Archive has no index; run ranlib to add one</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<p>可以发现，libsub.a很小。显然sub.c并没有被编译，记住ar只是一个打包命令，它不编译。</p>
<blockquote>
<p>也就是说，<strong>静态库</strong>只是 <code>.o</code> 的打包文件而已，它不想 <code>.so</code> 那样加了其他内容。</p>
</blockquote>
<br>


<h4 id="static"><a href="#static" class="headerlink" title="-static"></a>-static</h4><blockquote>
<p>那么除了静态库，有什么办法可以把动态库直接编译进app呢？</p>
</blockquote>
<p>有。使用 <code>-static</code> 选项。<br>该选项在编译时会直接把库编译进app。</p>
<p>例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chuck@chuck11:~/bsp$ ll</span><br><span class="line">total 32</span><br><span class="line">drwxrwxr-x  2 chuck chuck 4096 Apr 19 01:08 ./</span><br><span class="line">drwxr-xr-x 17 chuck chuck 4096 Apr 18 18:51 ../</span><br><span class="line">-rwxrwxr-x  1 chuck chuck 7896 Apr 19 01:06 libsub.so*</span><br><span class="line">-rw-rw-r--  1 chuck chuck  153 Apr 12 12:52 main.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck  139 Apr 12 12:51 Makefile</span><br><span class="line">-rw-rw-r--  1 chuck chuck   52 Apr 12 12:51 sub.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck   19 Apr 12 12:51 sub.h</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ gcc -static -o main main.c -I ./ -L ./ -lsub</span><br><span class="line">/usr/bin/ld: cannot find -lsub</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ gcc -c sub.c </span><br><span class="line">chuck@chuck11:~/bsp$ ar rcs -o libsub.a sub.o </span><br><span class="line">chuck@chuck11:~/bsp$ gcc -static -o main main.c -I ./ -L ./ -lsub</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ ll</span><br><span class="line">total 868</span><br><span class="line">drwxrwxr-x  2 chuck chuck   4096 Apr 19 01:12 ./</span><br><span class="line">drwxr-xr-x 17 chuck chuck   4096 Apr 18 18:51 ../</span><br><span class="line">-rw-rw-r--  1 chuck chuck   1680 Apr 19 01:12 libsub.a</span><br><span class="line">-rwxrwxr-x  1 chuck chuck   7896 Apr 19 01:06 libsub.so*</span><br><span class="line">-rwxrwxr-x  1 chuck chuck 844760 Apr 19 01:13 main*</span><br><span class="line">-rw-rw-r--  1 chuck chuck    153 Apr 12 12:52 main.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck    139 Apr 12 12:51 Makefile</span><br><span class="line">-rw-rw-r--  1 chuck chuck     52 Apr 12 12:51 sub.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck     19 Apr 12 12:51 sub.h</span><br><span class="line">-rw-rw-r--  1 chuck chuck   1536 Apr 19 01:10 sub.o</span><br><span class="line">chuck@chuck11:~/bsp$</span><br></pre></td></tr></table></figure>
<p>我做了2个尝试：</p>
<ul>
<li>1）尝试用 <code>-static</code> 编译进自己的 <code>libsub.so</code> 库，但失败了。实践表明不能通过<br>   <code>-static</code> 将自己的动态库编译进app。</li>
<li>2）编出 <code>.a</code> 静态库，使用 <code>-static</code> 成功了。说明自己的静态库可以。</li>
</ul>
<p><em>注意，编出的main有 <code>844k</code></em></p>
<blockquote>
<p>难道 <code>libc</code> 默认库是静态库？不可能啊，如果是静态库，为什么现在main编出来大了整整 <code>100倍</code> ？</p>
</blockquote>
<p>我们可以通过 <code>ldd</code> 确认一个app到底使用了那些库：<br>参考：<br><a href="http://c.biancheng.net/view/7483.html" target="_blank" rel="noopener">ldd</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chuck@chuck11:~/bsp$ gcc -static -o main_static main.c -I ./ -L ./ -lsub</span><br><span class="line">chuck@chuck11:~/bsp$ gcc -o main_dynamic main.c -I ./ -L ./ -lsub</span><br><span class="line">chuck@chuck11:~/bsp$ ll</span><br><span class="line">total 880</span><br><span class="line">drwxrwxr-x  2 chuck chuck   4096 Apr 19 01:16 ./</span><br><span class="line">drwxr-xr-x 17 chuck chuck   4096 Apr 18 18:51 ../</span><br><span class="line">-rw-rw-r--  1 chuck chuck   1680 Apr 19 01:12 libsub.a</span><br><span class="line">-rwxrwxr-x  1 chuck chuck   7896 Apr 19 01:06 libsub.so*</span><br><span class="line">-rw-rw-r--  1 chuck chuck    153 Apr 12 12:52 main.c</span><br><span class="line">-rwxrwxr-x  1 chuck chuck   8328 Apr 19 01:16 main_dynamic*</span><br><span class="line">-rwxrwxr-x  1 chuck chuck 844760 Apr 19 01:16 main_static*</span><br><span class="line">-rw-rw-r--  1 chuck chuck    139 Apr 12 12:51 Makefile</span><br><span class="line">-rw-rw-r--  1 chuck chuck     52 Apr 12 12:51 sub.c</span><br><span class="line">-rw-rw-r--  1 chuck chuck     19 Apr 12 12:51 sub.h</span><br><span class="line">-rw-rw-r--  1 chuck chuck   1536 Apr 19 01:10 sub.o</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ ldd main_static </span><br><span class="line">    not a dynamic executable</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ ldd main_dynamic </span><br><span class="line">    linux-vdso.so.1 (0x00007fffbe917000)</span><br><span class="line">    libsub.so =&gt; not found</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbc7afeb000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007fbc7b5de000)</span><br></pre></td></tr></table></figure>
<p>我编了两个main，一个静态的（ <code>main_static</code> ），一个动态的（ <code>main_dynamic</code> ）。<br>使用 <code>ldd</code> 查看，非 <code>-static</code> 生成的main，使用的c库是 <code>libc.so.6</code> 确实是动态库。</p>
<blockquote>
<p>那自己的so和标准库的so，有什么区别呢？</p>
</blockquote>
<p>我们通过 <code>file</code> 看下文件类型：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chuck@chuck11:~/bsp$ file libsub.so </span><br><span class="line">libsub.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=e4d3fd11a9247f7c75680cc54340daf8b58f4cc8, not stripped</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ file libsub.a </span><br><span class="line">libsub.a: current ar archive</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ sudo file /lib/x86_64-linux-gnu/libc.so.6 </span><br><span class="line">[sudo] password for chuck: </span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6: symbolic link to libc-2.27.so</span><br><span class="line">chuck@chuck11:~/bsp$ </span><br><span class="line">chuck@chuck11:~/bsp$ su</span><br><span class="line">Password: </span><br><span class="line">root@chuck11:/home/chuck/bsp# whereis libc-2.27.so</span><br><span class="line">libc-2.27: /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">root@chuck11:/home/chuck/bsp# </span><br><span class="line">root@chuck11:/home/chuck/bsp# file /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">/lib/x86_64-linux-gnu/libc-2.27.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/l, BuildID[sha1]=b417c0ba7cc5cf06d1d1bed6652cedb9253c60d0, for GNU/Linux 3.2.0, stripped</span><br></pre></td></tr></table></figure>
<p>除了自己的是没有去符号的，没有什么区别。</p>
<blockquote>
<p>总之，实践表明：自己的库，要想 <code>-static</code> 编进app，只能通过ar打包为静态库。</p>
</blockquote>
<blockquote>
<p>至于 <code>strip</code> 工具，我们另开篇讲。本身不在gcc的范畴。<br><br></p>
</blockquote>
]]></content>
      <categories>
        <category>编译</category>
      </categories>
  </entry>
  <entry>
    <title>linux启动流程</title>
    <url>/2020/04/12/linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>梳理linux的启动流程。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windows             linux</span><br><span class="line">    bios                bootloader(uboot)</span><br><span class="line">    | 启动              | 启动</span><br><span class="line">    windos              linux内核(内核、驱动)</span><br><span class="line">    | 识别              | 识别</span><br><span class="line">    c盘                 根文件系统(自带的app、我们的app)</span><br><span class="line">    | 运行              | 启动</span><br><span class="line">    app                 app</span><br></pre></td></tr></table></figure>
<br>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux目录结构</title>
    <url>/2020/04/12/linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>介绍linux的目录结构。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux目录结构</span><br><span class="line">|-bin           基本命令，所有用户可使用（与开机有关，就是系统启动要用的）</span><br><span class="line">|-boot          启动文件，比如内核等</span><br><span class="line">|-dev           设备文件</span><br><span class="line">|-etc           配置文件</span><br><span class="line">|-home          家目录</span><br><span class="line">|-lib           库（&#x2F;bin &#x2F;sbin下的app用的库，&#x2F;usr&#x2F;bin &#x2F;usr&#x2F;sbin下的也可以放这里，没有限制）</span><br><span class="line">|-media         插上u盘等外设时会挂在到该目录</span><br><span class="line">|-mnt           用来挂在其他文件系统</span><br><span class="line">|-opt           可选程序</span><br><span class="line">|-proc          挂载虚拟的proc文件系统，可以查看各进程信息（proc，其实就是process，但现在</span><br><span class="line">                proc内容很多了</span><br><span class="line">|-root          root用户的家目录</span><br><span class="line">|-sbin          基本的系统命令，系统管理员才能使用（与开机有关，就是系统启动要用的）</span><br><span class="line">|-sys           用来挂载虚拟的sys文件系统，可查看系统信息</span><br><span class="line">|-tmp           临时目录，存放临时文件</span><br><span class="line">|-usr           unix software resource，存放可分享的与不可变动的数据（usr和var是一对，</span><br><span class="line">                usr的不可变动指开机后还在的。相对的，var是变动的，开机后就没了）</span><br><span class="line">|   |-bin       绝大部分用户可使用的指令（与开机无关）</span><br><span class="line">|   |-include   头文件</span><br><span class="line">|   |-lib       库</span><br><span class="line">|   |-local     系统管理员在本机自行安装、下载的软件</span><br><span class="line">|   |-sbin      非系统正常运行所需要的系统命令</span><br><span class="line">|   |-share     放置共享文件的地方，比如&#x2F;usr&#x2F;share&#x2F;man里存放帮助文件</span><br><span class="line">|   |-src       源码</span><br><span class="line">|-var           主要针对常态性变动的文件，包括缓存（cache）、log文件等</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>man</title>
    <url>/2020/04/12/man/</url>
    <content><![CDATA[<p>记录man的基础知识，常用的指令、系统调用等等的说明。</p>
<a id="more"></a>

<p><code>man man</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1   Executable programs or shell commands</span><br><span class="line">2   System calls (functions provided by the kernel)</span><br><span class="line">3   Library calls (functions within program libraries)</span><br><span class="line">4   Special files (usually found in &#x2F;dev)</span><br><span class="line">5   File formats and conventions eg &#x2F;etc&#x2F;passwd</span><br><span class="line">6   Games</span><br><span class="line">7   Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7)</span><br><span class="line">8   System administration commands (usually only for root)</span><br><span class="line">9   Kernel routines [Non standard]</span><br></pre></td></tr></table></figure>
<p>man这本书有9本（默认从第1本开始找，依次往后）：</p>
<ul>
<li>第一本讲系统指令<br>比如 <code>man ascii</code> 、<code>man sed</code> 等<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SED(1)                                            User Commands                                            SED(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       sed - stream editor for filtering and transforming text</span><br></pre></td></tr></table></figure>
左上角的 <code>SED(1)</code> 这个1就是第几本。</li>
<li>第二本讲系统调用<br>比如 <code>man 2 open</code> 、 <code>man select</code> 等<br>如果 <code>open</code> 不指定 <code>2</code> ，那么 <code>man</code> 默认查询的是 <code>openvt</code>。<br>而 <code>select</code> 在第一本书中没有类似的。</li>
<li>[FIX ME]<br>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>shell</title>
    <url>/2020/04/12/shell/</url>
    <content><![CDATA[<p>记录shell的基本语法、常用的使用技巧等。</p>
<a id="more"></a>

<p><strong>不一定非得写shell脚本再执行，可以直接执行</strong><br><code>for((i=0;i&lt;10;i++));do echo $i;done</code><br><br><br><strong>xargs cp结合使用</strong><br><code>find . -name &quot;*&quot; | xargs -i cp {}  /home/users/</code><br><br><br><strong>删除除了某个/某些文件外的其他文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;a1.c</span><br><span class="line">&gt;a2.c</span><br><span class="line">&gt;a3.c</span><br><span class="line"></span><br><span class="line">rm -rf !(a1*|a3*)</span><br></pre></td></tr></table></figure>
<p>结果就是，保留了 <code>a1.c</code>、 <code>a3.c</code>，删除了 <code>a2.c</code> 。<br><br></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu问题汇总</title>
    <url>/2020/04/12/ubuntu%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>记录常见的ubuntu使用过程中的问题，包括一些配置等。</p>
<a id="more"></a>

<h2 id="A-start-job-is-running-for-wait-for-network-to-be-Configured"><a href="#A-start-job-is-running-for-wait-for-network-to-be-Configured" class="headerlink" title="A start job is running for wait for network to be Configured"></a>A start job is running for wait for network to be Configured</h2><p>ubuntu 18.04<br>开机时会卡在这一步，原因应该是网络不通。<br>解决方式：<br><code>vim /etc/systemd/system/network-online.target.wants/systemd-networkd-wait-online.service</code><br>在[Service]标签下增加：<br><code>TimeoutStartSec=2sec</code><br><br></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>串口</title>
    <url>/2020/04/12/%E4%B8%B2%E5%8F%A3/</url>
    <content><![CDATA[<p>本post介绍所有的串口。如果后续发现内容过多，不便于浏览，会对内容做拆分。<br>uart、spi、i2c等各单独一个post。</p>
<a id="more"></a>

<p>串口电平有两种：TTL，RS232（传统的9针串口）。</p>
]]></content>
      <categories>
        <category>bsp</category>
      </categories>
  </entry>
  <entry>
    <title>知行合一</title>
    <url>/2020/04/18/%E7%9F%A5%E8%A1%8C%E5%90%88%E4%B8%80/</url>
    <content><![CDATA[<p>记录自己对 <code>知行合一</code> 的理解和感悟。</p>
<a id="more"></a>

<h2 id="大众的理解"><a href="#大众的理解" class="headerlink" title="大众的理解"></a>大众的理解</h2><p>知行合一，大家都听过，但大多数人的理解和王阳明讲的还是有很大差距。<br>绝大对数人的理解是：</p>
<ul>
<li>知道，但不去做，跟不知道一样</li>
<li>不知道，就去做，做了等于白做</li>
</ul>
<p>强调，做事情前要先了解相关的知识。光了解知识不行，得付出实践。</p>
<p>这样的理解是“对”的（注意我打的引号），但为什么我们就做不到呢。<br>我也在思考，我想原因是残酷的：</p>
<ul>
<li>我们所认为的 <code>知道</code> 其实是 <code>不知道</code> ，只是半瓶醋晃荡。<br>我们做事时，明明是我做过的事，为什么还是 <code>不会</code> ，总是 <code>犹豫</code> 、<br><code>不果断</code> ，甚至还要 <code>重新学一遍</code> 呢！！！<br><em>不论是生活中，还是工作中，你仔细想想。这种情况比比皆是。</em></li>
<li>不论学什么，总想先学了再说，永远动不起来。<br>结果就是又回到上面的一点！！！</li>
</ul>
<p>了解阳明心学后，给了我很大的冲击，醍醐灌顶。<br><br></p>
<h2 id="先贤的理解"><a href="#先贤的理解" class="headerlink" title="先贤的理解"></a>先贤的理解</h2><p>我们先来看看先贤们是怎么看待 <code>知行</code> 的。</p>
<p><strong>尚书</strong><br><code>知之匪艰 行之惟艰</code><br>知道并不难，行动才难。<br><br></p>
<p><strong>知礼大师</strong><br><code>智为行本则行借智生 行能成智则智借行成</code><br>智慧是行动的根本，反过来，行动能成（我的理解是创造、完善）智慧。<br><br></p>
<p><strong>朱熹</strong><br><code>知之愈明则行之愈笃 行之愈笃则知之益明</code><br>朱文公讲的更进一步了。<br>知道的越明了，行动起来越切实。反过来，行动越切实，知道的更明了。<br>朱老爷子讲的太棒了。<br><br></p>
<p>不论是佛教大师，还是理学大师，他们都认识到：<br><code>知、行，是相辅相成的</code><br>知能指导行，行的反馈能不断完善知。</p>
<p>但很奇怪，至少对我来说是这样。我确确实实读懂了这些话，但还是陷入<br>不能行动起来的尴尬境遇。<br>到底问题出在哪？<br><br></p>
<h2 id="阳明心学-知行合一"><a href="#阳明心学-知行合一" class="headerlink" title="阳明心学 - 知行合一"></a>阳明心学 - 知行合一</h2><p>理解了知礼、朱熹的话，我也去努力实践了，但仍然没法做到 <code>行必笃</code> 。<br>工作中、生活中，总是会范同样的错误，被请教问题时，总会出现解释不清的情况。<br>这就像一个泥潭一样，没法脱身。</p>
<p>直到，我遇到了 <code>王阳明</code> ，我遇到了 <code>阳明心学</code> 。</p>
<p>有不少人认为王阳明被过度神话，但对我来说，他和他的心学确确实实是我前进道路<br>中出现的一盏明灯。<br>我的心不再浮躁，变得平和。<br>我渐渐忽略他人对我的看法，由他人审视，变为自我审视。<br>我的一切行动不再漫无目的，心不再变的不安。<br>我对他人、社会的看法甚至逐渐有了一种“上帝视角”。</p>
<p><strong>谁是圣人</strong><br>阳明龙场悟道，参悟：<br><code>圣人之道吾性具足 不假外求</code><br><code>向之求理于事物者误也</code><br>人人本身就具备成为圣人的品质，拿其他事物来衡量自己，谬误。</p>
<p>当时读到这句话，后背一凉，茅塞顿开。<br>我们一直都在跟别人比，从小的教育就是竞争，竞争，竞争。<br>我们成功的标杆永远是别人。</p>
<p>当我们看到其他人会这个，会那个，懂这个，懂那个时，总想着我不能被比下去，<br>我也要去学。<br>现在回想，这么做对绝大多数人是错误的：</p>
<ul>
<li>你想去学的时候，你是不是放下了手头正在做的事。<br>这些正在做的事，你做好了吗？你真的会了吗？下次再让你做，你会不犯错的<br>把它做好吗？<br>这些你正在做，需要做的都没有学会，都还只是半瓶醋，你就半途而废了！！！</li>
<li>不但上面的半途而废了，你羡慕其他人的，发誓要学的，最后你学到了吗？？？</li>
</ul>
<p>让我们换个视角。<br>站在旁边看自己做事的不再是别人（你的亲朋好友、你的同事领导），而是你自己。<br>想象一下，你灵魂脱壳，站在旁边审视你自己。<br>我现在做的好不好是由我自己决定的，我主宰我自己。</p>
<p><strong>知行合一</strong><br>当我做到，我就是圣人，我的人生由我自己主宰时。我的心里障碍已经完全不存在了。<br>我甚至开始以上帝视角观察这个社会，观察其他人。<br>我能做到专注于自己的事上，完全不被身边的环境干扰。那些干扰（同事的讨论等等）<br>逐渐逐渐被我漠视了。自身进入了一种 <code>心流</code> 模式。</p>
<p>当能做到这一步时，是时候谈谈阳明先生的 <code>知行合一</code> 了。</p>
<p>不论是佛学、理学，他们都把 <code>知</code> 和 <code>行</code> 分开了。<br><em>这也是我们始终做不到 <code>知</code> 的原因</em><br>我们付诸实践，完成了生活、工作中的任务，就认为自己懂了，已经知了。其实完全<br>没有到知的地步。你很可能只是在照猫画虎抄作业而已。<br>但我们总会给自己打上一个，这块我会了，的标签。<br>这个错觉是谁给的？行，给的。我以前做过，既然以前做过，这次我也会。很可能是<br>再抄一次作业。</p>
<p>问题到底在哪？再问一次自己。<br>是因为知、行分开了。</p>
<p>王阳明提出：<br><code>知之真切笃实处即是行 行之明觉精察处即是知 知行工夫本不可离</code></p>
<p>对知识了解的明明白白、分毫不差，那才是行。<br>要做到明明白白、分毫不差，你不去行是不可能呢。经历了很多行，才能做到分毫不差。<br>明觉精察，就是做事情，非常清晰，一丝不乱，能类似于本能了。<br>你仔细回想，当别人问你一个知识点时，你还需要想一想，那就是其实还没懂，似懂非懂！<br>你只有脱口而出，100%确定的讲出来，那才是懂。</p>
<p>这就是知行合一。</p>
<p>当我们能做到，做事处于 <code>心流</code> 模式，能做到 <code>自我审视</code> ，能坚定不渝的<br>完成每一个 <code>知行</code> ，能以 <code>上帝视角</code> 审视周遭。你会得到一种超然的感觉。</p>
]]></content>
      <categories>
        <category>阳明心学</category>
      </categories>
  </entry>
  <entry>
    <title>网站整合</title>
    <url>/2020/04/20/%E7%BD%91%E7%AB%99%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<p>一些很nice的网站，感谢所有为此付出的人们，向你们致敬！</p>
<a id="more"></a>

<h2 id="lookdiv-激活码"><a href="#lookdiv-激活码" class="headerlink" title="lookdiv-激活码"></a>lookdiv-激活码</h2><p><a href="http://lookdiv.com/" target="_blank" rel="noopener">lookdiv</a><br>我用来激活 <code>clion</code> ，但从网站说明上看，它所提供的激活码可以激活任何软件。<br>钥匙：<code>lookdiv</code><br>最新激活码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E70JHCOV2H-eyJsaWNlbnNlSWQiOiJFNzBKSENPVjJIIiwibGljZW5zZWVOYW1lIjoi5bGx5Lic55CG5bel5aSn5a2mIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAyMS0wMi0xOCJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAyMS0wMi0xOCJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAyMS0wMi0xOCJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjAyMS0wMi0xOCJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAyMS0wMi0xOCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDIxLTAyLTE4In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMjEtMDItMTgifV0sImhhc2giOiIxNjc5MTgwMy8wIiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-qlgtO4xVGHX&#x2F;r45fIKMaR6B9pWQtucrCYVsz0o00crcAiYN1k&#x2F;kSMygggYl187B0u0jeXQCe4BmQIItKL79x6NwoPn43inreVhZ88f4+Cbl+V&#x2F;KGeAYeybon+7YoTs8FY4+31ANW&#x2F;LwBPxkPnlErxYdQ6oc&#x2F;k6mnxIOm5Nf8WjKRfYYIl5Bhmdt1gHMGgFsocCcTLLiqDUGEcPj5tUIJXwwYaeKAR3YGXm&#x2F;P73QpnYR&#x2F;BcGaodBN3jprQRxsS5Ia5y06rrDAJcPSZuttAFpAit&#x2F;4o&#x2F;gq2XzhrjaBCtOMxNzk3XEAT82glTlWQOQx6KnRq6D7WUXzd81g44aP+Dca5Q&#x3D;&#x3D;-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO&#x2F;5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij&#x2F;78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB&#x2F;xVy&#x2F;VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE&#x2F;EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn&#x2F;72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN&#x2F;lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D&#x2F;cXmgpOyW&#x2F;1SmBz3XjVIi&#x2F;zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV&#x2F;bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit&#x2F;pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="不蒜子-极简网页计数器"><a href="#不蒜子-极简网页计数器" class="headerlink" title="不蒜子-极简网页计数器"></a>不蒜子-极简网页计数器</h2><p><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a><br>本站的计数就是通过不蒜子的api实现的。<br><br></p>
<h2 id="比特虫-ico图标制作"><a href="#比特虫-ico图标制作" class="headerlink" title="比特虫-ico图标制作"></a>比特虫-ico图标制作</h2><p><a href="http://www.bitbug.net/" target="_blank" rel="noopener">比特虫</a><br>可以很方便的制作特定尺寸的图标。<br><br></p>
<h2 id="C语言中文网"><a href="#C语言中文网" class="headerlink" title="C语言中文网"></a>C语言中文网</h2><p><a href="http://c.biancheng.net/" target="_blank" rel="noopener">C语言中文网</a><br>整理的很好，绝大部分是收费内容，但不收费的部分也非常不错。<br><br></p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
</search>
